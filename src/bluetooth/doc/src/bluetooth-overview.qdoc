/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the documentation of the Qt local connectivty modules.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.  Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: http://www.gnu.org/copyleft/fdl.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\ingroup technology-apis
\title Qt Bluetooth Overview
\page qtbluetooth-overview.html
\brief The Qt Bluetooth API enables connectivity with other regular Bluetooth
       and Bluetooth Low Energy enabled devices.

\tableofcontents

    With the Qt Bluetooth API typical use cases are:

        \list
        \li Retrieve information about the local Bluetooth device.
        \li Scan for other Bluetooth devices in range and retrieve information about them.
        \li Push files to remote devices using the OBEX Object Push Profile (OPP).
        \li Connect to remote devices through a RFCOMM channel using the Serial Port Profile (SPP).
        \li Create a RFCOMM server that allows incoming connections using SPP.
        \li Retrieve specification about Bluetooth Low Energy device.
        \li Connect to Bluetooth Low Energy device.
        \li Receive advertisement from Bluetooth Low Energy device.
        \endlist

    The following sections describe how to use the Qt Bluetooth C++ API classes
    for the above use cases.

    \section1 Retrieving Local Device Information

    The Qt Bluetooth API has three main purposes. The first one is to
    obtain local and remote device information. The first steps in retrieving device information is
    to check if Bluetooth is available on the device and read the local device address and name. The
    QBluetoothLocalDevice is the one to provide all of this information. Additionally you can use it
    to turn Bluetooth on and off and set the visibility on the device.

    \snippet doc_src_qtbluetooth.cpp turningon

    \section1 Scanning for Bluetooth Devices

    Similar to the QBluetoothLocalDevice, the API offers QBluetoothDeviceInfo which provides
    that information for remote devices. Although you can just create QBluetoothDeviceInfo objects on
    your own and fill them with data, the easier way is to use the QBluetoothDeviceDiscoveryAgent to
    start an automated search for visible Bluetooth devices within the connectable range.

    \snippet doc_src_qtbluetooth.cpp discovery

    \section1 Pushing Files to Remote Devices

    Once the desired device is found, there are two main use cases provided by Qt Bluetooth. The
    simpler is to send files via the Obex Object Push Profile (OPP). As the name describes, this
    profile can only push files from one device to another, but not pull files or browse the remote
    file system. Because of this limitation, this profile does not require the two devices to be
    paired before exchanging data. To push files to remote devices, create a
    QBluetoothTransferRequest and ask the QBluetoothTransferManager to push the file contained in
    the request by calling the put() function.

    \snippet doc_src_qtbluetooth.cpp sendfile

    \section1 Exchanging Data Between Devices

    The more flexible approach for communication between two Bluetooth enabled devices, is to
    create a virtual serial port connection and freely exchange data over that connection. This can
    be done by the Serial Port Profile (SPP). The Serial Port Profile emulates a serial connection
    over the Bluetooth transport protocol RFCOMM.

    To be able to create SPP connections, you need to register a Server one one device by using
    QRfcommServer.

    \snippet btchat/chatserver.cpp Create the server

    Connect to this server from another device playing the client role by using a
    QBluetoothSocket.

    \snippet btchat/chatclient.cpp startClient

    Using such a connection allows to exchange any form of data in both directions.
    It is perfectly suited for gaming or for syncing the state between two instances of
    an application on two devices. For more detailed descriptions on how to configure the server
    and client, please refer to the detailed description sections in the QRfcommServer and
    QBluetoothSocket classes. A good example to start with SPP is the \l{btchat}{Bluetooth Chat}
    example.

    \section1 Bluetooth Low Energy

    Bluetooth Low Energy (in later text BLE), also known as Bluetooth Smart is a wireless computer
    network technology, which was officially introduced in 2011. It works at the same,
    2,4HGz frequency, as ”classic” Bluetooth. The main difference is, as stated by its technology name,
    low energy consumption. It provides an opportunity for BLE devices to operate for months,
    even years, on coin-cell batteries. This technology was introduced with Bluetooth v 4.0
    and devices which support this technology are called Bluetooth Smart Ready Devices.
    The key features of technology are:
    \list
    \li Ultra-low peak, average and idle mode power consumption
    \li Ability to run for years on standard, coin-cell batteries
    \li Low cost
    \li Multi-vendor interoperability
    \li Enhanced range
    \endlist

    BLE uses a client-server architecture. The server (BLE device) offers services (temperature,
    heart rate or any other measurements) and advertises them. The client (PC, smartphone
    or any other Bluetooth Smart Ready device) connects to the server and reads the values
    advertised by the server. The BLE API is based on GATT (Generic Attribute Profile) concepts.
    GATT commands are initiated by the client, as mentioned above, and the server is receiving
    GATT commands and sends replies.

    These GATT commands initiate the services, which consist of characteristics. A characteristic
    is data that is being transferred. Each characteristic has descriptors, which give additional
    information about the characteristic. Services, characteristics and descriptors are recognized
    by their 128bits UUIDs.

    To be able to get and read characteristics, it is required to connect to the LE device service.

    \code
    QObject::connect(m_serviceDiscoveryAgent, SIGNAL(serviceDiscovered(const QLowEnergyServiceInfo&)),
                this, SLOT(addLowEnergyService(const QLowEnergyServiceInfo&)));
    QObject::connect(m_serviceDiscoveryAgent, SIGNAL(finished()), this, SLOT(serviceScanDone()));
    m_serviceDiscoveryAgent->setRemoteAddress(device.address());
    m_serviceDiscoveryAgent->start();
    lowEnergyController = new QLowEnergyController();
    QObject::connect(lowEnergyController, SIGNAL(connected(QLowEnergyServiceInfo)),
                this, SLOT(serviceConnected(QLowEnergyServiceInfo)));
    QObject::connect(lowEnergyController, SIGNAL(error(QLowEnergyServiceInfo)),
                this, SLOT(errorReceived(QLowEnergyServiceInfo)));
    QObject::connect(lowEnergyController, SIGNAL(valueChanged(QLowEnergyCharacteristicInfo)),
                this, SLOT(receiveMeasurement(QLowEnergyCharacteristicInfo)));
    QObject::connect(lowEnergyController, SIGNAL(disconnected(QLowEnergyServiceInfo)),
                this, SLOT(serviceDisconnected(QLowEnergyServiceInfo)));

    \endcode

    We start a service discovery with a \l QBluetoothServiceDiscoveryAgent class and connect its
    signal \l serviceDiscovered(QLowEnergyServiceInfo) to our slot
    \l addLowEnergyService(QLowEnergyServiceInfo). This way, it is possible to store all LE services
    or connect to the desired one. \l QLowEnergyController is used for connecting to service,
    receiving emitted errors from the service and disconnecting from the service.

    Even though it is possible to connect to an LE service before the service scan is done,
    it is advisable to do it after the service scan is done.

    \code
    void serviceScanDone()
    {
        lowEnergyController->connectToService(wantedLowEnergyService);
    }
    \endcode

    Here, the \c wantedLowEnergyService can be one service or you can pick more or all services
    to connect. Some LE devices, become available one or two seconds after service scan.

    \code
    void serviceConnected(const QLowEnergyServiceInfo &leService)
    {
        QList<QLowEnergyCharacteristicInfo> lowEnergyCharacteristics = leService.getCharacteristics();
        for (int i = 0; i<lowEnergyCharacteristics.size(); i++) {
            QLowEnergyCharacteristicInfo wantedCharacteristic =
                        QLowEnergyCharacteristicInfo(lowEnergyCharacteristics.at(i));
            lowEnergyController->enableNotifications(wantedCharacteristic);
        }
    }
    \endcode

    In the code example above all characteristics will be enabled for the notifications, but not
    all of them have that option as explained in \l QLowEnergyController documentation. It is possible
    to select only one characteristic, for instance \l QBluetoothUuid::HeartRateMeasurement.

    Finally, to receive updates, the receiveMeasurement(QLowEnergyCharacteristicInfo) slot was defined.

    \code
    void HeartRate::receiveMeasurement(const QLowEnergyCharacteristicInfo &characteristic)
    {
        wantedCharacteristic = QLowEnergyCharacteristicInfo(characteristic);
        wantedCharacteristic.value();
    }
    \endcode

    The returned value is the hexadecimal value. The procedure of reading and converting hexadecimal
    value properly depends on the BLE devices that is sending updates since every device has a different
    value structure.


*/
